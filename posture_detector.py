import cv2
import numpy as np
import math
import os
import sys
import warnings
import time
from contextlib import contextmanager

# Suppress TensorFlow/MediaPipe warnings
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3'
os.environ['OPENCV_LOG_LEVEL'] = 'ERROR'
os.environ['OPENCV_VIDEOIO_DEBUG'] = '0'
warnings.filterwarnings('ignore', category=UserWarning, module='google.protobuf')
warnings.filterwarnings('ignore', category=FutureWarning, module='mediapipe')

# Set OpenCV log level to ERROR only (suppresses WARN messages)
# Only available in OpenCV 4.x
try:
    cv2.setLogLevel(3)
except AttributeError:
    pass  # setLogLevel not available in this OpenCV version


@contextmanager
def suppress_stderr():
    """Context manager to suppress stderr output (for C++ library warnings)."""
    stderr_fd = sys.stderr.fileno()
    # Save a copy of the original stderr file descriptor
    stderr_dup = os.dup(stderr_fd)
    # Open /dev/null
    devnull_fd = os.open(os.devnull, os.O_WRONLY)
    try:
        # Redirect stderr to /dev/null
        os.dup2(devnull_fd, stderr_fd)
        yield
    finally:
        # Restore stderr
        os.dup2(stderr_dup, stderr_fd)
        os.close(stderr_dup)
        os.close(devnull_fd)


# Import MediaPipe with suppressed stderr to avoid initialization warnings
with suppress_stderr():
    import mediapipe as mp


class PostureDetector:
    """Posture detection using MediaPipe Pose."""
    
    def __init__(self):
        """Initialize MediaPipe Pose solution."""
        self.mp_pose = mp.solutions.pose
        self.mp_drawing = mp.solutions.drawing_utils
        self.mp_drawing_styles = mp.solutions.drawing_styles
        # Initialize Pose with suppressed stderr to avoid absl warnings
        with suppress_stderr():
            self.pose = self.mp_pose.Pose(
                min_detection_confidence=0.5,
                min_tracking_confidence=0.5
            )
            # Sleep briefly to allow async C++ warnings from TensorFlow Lite delegate
            # initialization to be written to the suppressed stderr before restoring.
            # This is necessary because warnings are generated by background threads.
            time.sleep(0.1)
    
    def calculate_tilt(self, left_shoulder, right_shoulder):
        """Calculate shoulder tilt angle."""
        if left_shoulder is None or right_shoulder is None:
            return 0
        
        x_diff = right_shoulder[0] - left_shoulder[0]
        y_diff = right_shoulder[1] - left_shoulder[1]
        
        # Calculate angle from horizontal (0 degrees means level shoulders)
        angle = math.degrees(math.atan2(y_diff, x_diff))
        return abs(angle)
    
    def process_frame(self, frame):
        """
        Process a video frame for posture detection.
        
        Returns:
            processed_frame: Frame with pose landmarks drawn
            tilt_angle: Shoulder tilt angle in degrees
            is_bad_posture: Boolean indicating if posture is bad
        """
        # Convert BGR to RGB
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        
        # Process the frame
        results = self.pose.process(rgb_frame)
        
        tilt_angle = 0
        left_shoulder = None
        right_shoulder = None
        
        if results.pose_landmarks:
            # Draw pose landmarks on the frame
            self.mp_drawing.draw_landmarks(
                frame,
                results.pose_landmarks,
                self.mp_pose.POSE_CONNECTIONS,
                landmark_drawing_spec=self.mp_drawing_styles.get_default_pose_landmarks_style()
            )
            
            # Get shoulder positions
            landmarks = results.pose_landmarks.landmark
            h, w, c = frame.shape
            
            # Left shoulder (landmark 11)
            left_shoulder_lm = landmarks[self.mp_pose.PoseLandmark.LEFT_SHOULDER.value]
            left_shoulder = (int(left_shoulder_lm.x * w), int(left_shoulder_lm.y * h))
            
            # Right shoulder (landmark 12)
            right_shoulder_lm = landmarks[self.mp_pose.PoseLandmark.RIGHT_SHOULDER.value]
            right_shoulder = (int(right_shoulder_lm.x * w), int(right_shoulder_lm.y * h))
            
            # Calculate tilt angle
            tilt_angle = self.calculate_tilt(left_shoulder, right_shoulder)
            
            # Draw line between shoulders
            cv2.line(frame, left_shoulder, right_shoulder, (0, 255, 0), 2)
            
            # Draw shoulder points
            cv2.circle(frame, left_shoulder, 5, (0, 0, 255), -1)
            cv2.circle(frame, right_shoulder, 5, (0, 0, 255), -1)
        
        return frame, tilt_angle, left_shoulder, right_shoulder
    
    def release(self):
        """Release MediaPipe resources."""
        self.pose.close()
